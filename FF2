--POOG FOOG

local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/xHeptc/Kavo-UI-Library/main/source.lua"))()
local Window = Library.CreateLib("Poog foogs FF2 Sub to Poog Foog for more", "Midnight")

-- MAIN
local Main = Window:NewTab("Main")
local MainSection = Main:NewSection("Main")

MainSection:NewButton("Ball Mag", "When close ball magnets", function()
    local plr = game.Players.LocalPlayer
local rs = game:GetService("RunService")

function magBall(ball)
   if ball and plr.Character then
       firetouchinterest(plr.Character["Left Arm"], ball, 0)
       task.wait()
       firetouchinterest(plr.Character["Left Arm"], ball, 1)
   end
end

rs.Stepped:Connect(function()
   for i,v in pairs(workspace:GetChildren()) do
       if v.Name == "Football" and v:IsA("BasePart") then
           magBall(v)
       end
   end
end)



end)


MainSection:NewButton("Ball predictions", "ButtonInfo", function()
	local Grapher = {}

	--// UI Setup
	do
		local GrapherSection = Variables.CatchingTab:AddSection("Grapher")
		GrapherSection:AddToggle("Enabled", {flag = "Grapher_Enabled"}, function() end)
	end
	
	Grapher.Marker = Instance.new("Part")
	Grapher.Marker.Anchored = true
	Grapher.Marker.Transparency = .8
	Grapher.Marker.Color = Color3.fromRGB(255, 0, 255)
	Grapher.Marker.CanCollide = false
	Grapher.Marker.Name = "Marker"
	
	Grapher.Params = RaycastParams.new()
	Grapher.Params.IgnoreWater = true 
	Grapher.Params.FilterType = Enum.RaycastFilterType.Whitelist
	
	Grapher.CastStep = 3 / 60
	
	Grapher.LastSavedPower = 60
	
	function Grapher:GetCollidables()
		local Collidables = {}
		
		for _, BasePart in ipairs(workspace:GetDescendants()) do
			if BasePart:IsA("BasePart") and BasePart.CanCollide == true then
				table.insert(Collidables, BasePart)
			end
		end
		return Collidables
	end
	
	function Grapher:WipeMarkers()
		for i,v in pairs(workspace:GetChildren()) do
			if v.Name == "Marker" then v:Destroy() end
		end
	end
	
	function Grapher:GetLanding(origin, velocity, c)
		local Elapsed = 0
		local LastPos = origin
		
		self.Params.FilterDescendantsInstances = self:GetCollidables()
		
		local Football_Highlight;
	
		if c then
			Football_Highlight = Instance.new("Highlight", game.CoreGui)
			Football_Highlight.Adornee = c 
			Football_Highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
			Football_Highlight.Enabled = true  
		end
	
		while true do
			Elapsed += Grapher.CastStep
	
			local nPos = origin + velocity * Elapsed - Vector3.new(0, .5 * 28 * Elapsed ^ 2, 0)
			
			local Marker = self.Marker:Clone(); Marker.Parent = workspace; Marker.Position = nPos
			if c and Football_Highlight and c.Parent ~= workspace or c and not c:FindFirstChildOfClass("BodyForce") then
				Football_Highlight:Destroy()
				self:WipeMarkers()
				break
			end
	
			task.wait()
		end
	end
	
	do
		workspace.ChildAdded:Connect(function(child)
			if child.Name == "Football" and child:IsA("BasePart") and Variables.CatchingTab.Flags["Grapher_Enabled"] then
				local tempCon; tempCon = child:GetPropertyChangedSignal("Velocity"):Connect(function()
					Grapher:GetLanding(child.Position, child.Velocity, child)
					tempCon:Disconnect()
				end)
			end
		end)     
	
		--[[
		Variables.Client.PlayerGui.ChildAdded:Connect(function(child)
			if child.Name == "BallGui" then
				task.spawn(function()
					while true do if Variables.CatchingTab.Flags["Grapher_Enabled"] then
						if child.Parent ~= Variables.Client.PlayerGui then break end 
						local Frame = child:FindFirstChild("Frame")
						local Display = Frame and Frame:FindFirstChild("Disp")
						local Power = Display and tonumber(Display.Text)
						if Power ~= nil then
							Grapher.LastSavedPower = Power
						end 
	
						Grapher:GetLanding(Variables.Character:FindFirstChild("Head").Position, ((Variables.Client:GetMouse().Hit.Position - Variables.Character:FindFirstChild("Head").Position).Unit * Grapher.LastSavedPower))
						task.wait(.2)
						Grapher:WipeMarkers()
						task.wait()
					end
					end
				end)
			end
		end)
		--]]
	end
	
	
	return Grapher 
end)




MainSection:NewButton("Click TP (F)", "ButtonInfo", function()
    local Player = game:GetService'Players'.LocalPlayer;
local UIS = game:GetService'UserInputService';
UIS.InputBegan:connect(function(UserInput)
        if UserInput.UserInputType == Enum.UserInputType.Keyboard and UserInput.KeyCode == Enum.KeyCode.F then
            _G.Running = true
                while wait(0.09) and _G.Running == true do
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame + game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame.lookVector * 1.4

end
        end
end)
UIS.InputEnded:connect(function(UserInput)
        if UserInput.UserInputType == Enum.UserInputType.Keyboard and UserInput.KeyCode == Enum.KeyCode.F then
                _G.Running = false
        end
end)
end)











MainSection:NewButton("Tracers", "ButtonInfo", function()
	_G.TeamCheck = false
    _G.Tracers = true
    --// local shit stuff i guess \\--
    local lp = game.Players.LocalPlayer
    local camera = game:GetService("Workspace").CurrentCamera
    local CurrentCamera = workspace.CurrentCamera
    local worldToViewportPoint = CurrentCamera.worldToViewportPoint
    for i,v in pairs(game.Players:GetChildren()) do
        local Tracer = Drawing.new("Line")
        Tracer.Visible = false
        Tracer.Color = Color3.new(255,0,255)
        Tracer.Thickness = 2
        Tracer.Transparency = 1
        
        function traces()
            game:GetService("RunService").RenderStepped:Connect(function()
                if v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v ~= lp and v.Character.Humanoid.Health > 0 then
                    local Vector, OnScreen = camera:worldToViewportPoint(v.Character.HumanoidRootPart.Position)
                    
                    if OnScreen then
                        Tracer.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
                        Tracer.To = Vector2.new(Vector.X, Vector.Y)
                        
                        if _G.TeamCheck and v.TeamColor == lp.TeamColor then
                            Tracer.Visible = false
                        else
                            Tracer.Visible = true
                        end
                    else
                        Tracer.Visible = false
                    end
                else
                    Tracer.Visible = false
                end
                if _G.Tracers == false then
                    Tracers.Visible = false
                end
            end)
        end
        coroutine.wrap(traces)()
    end
    game.Players.PlayerAdded:Connect(function()
        local Tracer = Drawing.new("Line")
        Tracer.Visible = false
        Tracer.Color = Color3.new(255,0,0)
        Tracer.Thickness = 2
        Tracer.Transparency = 2
        
        function traces()
            game:GetService("RunService").RenderStepped:Connect(function()
                if v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v ~= lp and v.Character.Humanoid.Health > 0 then
                    local Vector, OnScreen = camera:worldToViewportPoint(v.Character.HumanoidRootPart.Position)
                    if OnScreen then
                        Tracer.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
                        Tracer.To = Vector2.new(Vector.X, Vector.Y)
                        
                        if _G.TeamCheck and v.TeamColor == lp.TeamColor then
                            Tracer.Visible = false
                        else
                            Tracer.Visible = true
                        end
                    else
                        Tracer.Visible = false
                    end
                else
                    Tracer.Visible = false
                end
                if _G.Tracers == false then
                    Tracers.Visible = false
                end
            end)
        end
        coroutine.wrap(traces)()
    end)
 



end)
